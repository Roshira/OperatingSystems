Запустивши програму ми бачимо:
Висновки:
1. LRU краще за RAND на 0.95%.
2. CLOCK працює майже так само добре, як LRU.
DESKTOP-ONQOHH3:~/OperatingSystems/Part22Q4$ nano program.py
DESKTOP-ONQOHH3:~/OperatingSystems/Part22Q4$ python program.py
Генерація трейсу (10000 звернень, 100 сторінок, кеш=25)...
Тип: 80% звернень до 20% адресного простору (локальність).
------------------------------
LRU Hit Rate:        67.13%
RAND Hit Rate:       58.75%
CLOCK (1 bit) Hit:   63.80%
CLOCK (2 bits) Hit:  64.54%
CLOCK (3 bits) Hit:  64.85%
------------------------------

Висновки:
1. LRU краще за RAND на 8.38%.
2. CLOCK трохи гірше LRU, але краще RAND.

1. Як згенерувати трасу з локальністю (How can you generate such a trace)?
Локальність (locality) означає, що програми схильні звертатися до одних і тих самих даних часто. Щоб згенерувати таку трасу, використовується модель "гарячих" і "холодних" сторінок (часто базується на принципі Парето 80/20):

Метод: Розділіть адресний простір на дві частини. Менша частина (наприклад, 20% сторінок) оголошується "гарячою", а решта (80%) — "холодною".

Генерація: Налаштуйте генератор випадкових чисел так, щоб більшість звернень (наприклад, 80% часу) припадала на "гарячі" сторінки, а решта 20% часу — на "холодні".

Результат: отримуємо потік даних, де невелика група сторінок зустрічається дуже часто, імітуючи цикли або часте використання змінних у реальних програмах.

2. Як LRU працює з нею (How does LRU perform on it)?
LRU (Least Recently Used) працює відмінно на трасах з локальністю, за умови, що розмір кешу достатній для зберігання "гарячого набору" (working set).

Механізм: Оскільки до "гарячих" сторінок звертаються часто, LRU постійно переміщує їх у початок черги (або оновлює час доступу). Вони майже ніколи не витісняються.

Витіснення: LRU ефективно знаходить і викидає "холодні" сторінки, до яких звернення відбуваються рідко, звільняючи місце для важливих даних.

Застереження: Якщо кеш менший за набір "гарячих" сторінок, LRU почне працювати погано (виникне thrashing), що ми бачили у вашому першому тесті.

3. Наскільки LRU кращий за RAND (How much better than RAND is LRU)?
RAND (Випадковий): Не враховує історію. Він з однаковою ймовірністю може викинути "гарячу" сторінку, яка знадобиться через мілісекунду, і "холодну", яка не знадобиться ніколи.

Порівняння:

При наявності локальності LRU завжди перемагає.

У експерименті (де кеш = 25) LRU показав результат ~67%, а RAND — ~58%. Різниця у 8-9% є дуже суттєвою для продуктивності комп'ютера. У реальних системах ця різниця може бути ще більшою.

4. Як працює CLOCK (How does CLOCK do)?
CLOCK (алгоритм годинника) працює майже так само добре, як LRU, але потребує значно менше ресурсів.

Результат: У тесті CLOCK (1 біт) показав 63.8%, що лише трохи менше за ідеальний LRU (67.1%), але значно краще за RAND (58.7%).

Чому: CLOCK використовує "біт використання" (use bit). Якщо сторінка "гаряча" (до неї зверталися), біт дорівнює 1. Алгоритм дає такій сторінці "другий шанс" і не викидає її, пропускаючи та шукаючи сторінку з бітом 0 ("холодну"). Це дозволяє йому емулювати поведінку LRU.

5. А як щодо CLOCK з різною кількістю бітів (How about CLOCK with different numbers of clock bits)?
Збільшення кількості бітів для CLOCK наближає його ефективність до чистого LRU.

1 біт (0 або 1): Пам'ятає лише "використовувалася нещодавно чи ні". Це базова версія.

Більше бітів (лічильник): Дозволяє запам'ятати наскільки часто або наскільки давно сторінка використовувалася. Це робить алгоритм більш точним у визначенні "найстарішої" сторінки.

Ваш результат:

1 біт: ~63.80%

2 біти: ~64.54%

3 біти: ~64.85% (все ближче до LRU 67.13%)

Висновок: Додавання бітів покращує точність, але навіть найпростіший 1-бітний CLOCK вже є дуже ефективним рішенням, яке використовується в багатьох сучасних ОС.
